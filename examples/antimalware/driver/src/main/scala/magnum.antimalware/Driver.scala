package magnum.antimalware

import java.io.{File,FileWriter}
import java.util.concurrent.atomic.AtomicInteger

import scala.actors._ // For Thread.sleep. TODO remove!
import scala.language.postfixOps
import scala.io.Source

import clasp._
import clasp.core._
import clasp.core.sdktools._

import scala.sys.process._
import scala.concurrent._
import ExecutionContext.Implicits.global

import scala.util.control.Breaks._

object Driver {
  lazy val infoRegex = """.*name='([^']*)'.*""".r
  var clasp: ClaspMaster = null

  var totalToProfile = 0
  var numProfiled: AtomicInteger = new AtomicInteger(0)

  def run(clasp: ClaspMaster, profilerApk: String,
      appsTag: String, arffTag: String,
      maxBenignApps: Option[Int], maxMaliciousApps: Option[Int]) {
    this.clasp = clasp

    val monkeyOpts = "--pct-syskeys 0 " +
      "--pct-appswitch 0 " +
      "--pct-anyevent 0 " +
      "-s 0 " +
      "--throttle 50 " +
      "1000" // 10000

    // Clean and make the `arffTag` directories.
    s"rm -rf ../arff/$arffTag" !!;
    s"mkdir -p ../arff/$arffTag/benign ../arff/$arffTag/malicious" !!
    val infoFile = new FileWriter(s"../arff/$arffTag/info.txt", false)
    infoFile.write("Information for these feature vectors.\n")
    infoFile.write(s"adb monkey options: '$monkeyOpts'.\n")
    infoFile.write(s"appsTag = $appsTag\n")
    infoFile.write(s"maxBenignApps = $maxBenignApps\n")
    infoFile.write(s"maxMaliciousApps = $maxMaliciousApps\n")
    infoFile.close()

    collectEmu("benign", profilerApk, appsTag, arffTag,
      monkeyOpts, maxBenignApps)
    collectEmu("malicious", profilerApk, appsTag, arffTag,
      monkeyOpts, maxMaliciousApps)

    var previousNumProfiled = 0; var count = 0;
    var minutesToTimeout = 10;
    println("Waiting for applications to finish profiling.")
    println("If nothing changes in " + minutesToTimeout + " minute(s), " +
      "assume we timed out and exit.")
    while (numProfiled.get < totalToProfile) {
      Thread.sleep(1000);
      count = (count + 1) % (60*minutesToTimeout)
      if (count == 0) {
        if (previousNumProfiled == numProfiled.get) {
          println("No applications profiled in " + minutesToTimeout
            + " minute(s). Exiting.")
          clasp.kill
          return
        }
      }
    }
    println("Profiled " + totalToProfile + " applications.")
    clasp.kill
  }

  // appsTag and arfftag are passed here because they showed
  // up null in the callback function if they are passed
  // as global?
  def collectEmu(classification: String, profilerApk: String,
      appsTag: String, arffTag: String, monkeyOpts: String,
      maxApps: Option[Int]) {
    var appsPath = s"../apps/$appsTag/$classification"
    var file: File = new File(appsPath)
    if (file.listFiles == null) {
      println(s"Warning: $appsPath contains no files.")
    }

    println(s"Adding $classification applications.")
    val startTime = System.currentTimeMillis()
    var i = 1
    breakable {
      for (apkFile <- file.listFiles) {
        if (maxApps.isDefined && i > maxApps.get) {
          break;
        }
        val apkName = apkFile.getName()
        // TODO: Don't add if we already have an arff.
        totalToProfile += 1
        val f = clasp.register_on_new_emulator(
            (emu: Emulator) =>
              profileApkCallback(emu, classification, apkName,
                profilerApk, appsTag, arffTag, monkeyOpts))
        f onSuccess {
          case data => println(
              s"""Emulator Task completed successfully on Node""" +
              s"""${data("node")},emulator ${data("serialID")}""")
          val total = numProfiled.incrementAndGet
          val time = System.currentTimeMillis() - startTime;
          println(s"Profiled $total in $time ms.")
        }
        f onFailure {
          case t => println(s"Future failed due to ${t.getMessage}")
          numProfiled.incrementAndGet
        }
        i += 1
      }
    }
  }

  // Don't use global variables in a callback!
  // This is why we pass `profilerApk` and `arffTag`.
  def profileApkCallback(emu: Emulator, classification: String,
      apkName: String, profilerApk: String, appsTag:String, arffTag: String,
      monkeyOpts: String):
      Map[String, Any] = {
    val startTime = System.currentTimeMillis();
    var result = scala.collection.mutable.Map[String, Any]()
    // TODO: Use the same logging mechanism as clasp.
    println(s"\n===========Profiling application: $apkName===========")
    result("serialID") = emu.serialID
    result("node") = "hostname".!!.stripLineEnd

    println("Installing the profiling application.")
    sdk.install_package(emu.serialID, profilerApk, true)

    var command = s"[[ -d /sdcard/magnum ]] || mkdir /sdcard/magnum"
    sdk.remote_shell(emu.serialID, command)

    var isMalware = "positive"
    if (classification == "benign") isMalware = "negative"
    println(s"Setting the classification to '$isMalware'.")
    command = s"echo $isMalware> /sdcard/magnum/classification"
    sdk.remote_shell(emu.serialID, command)

    val apkPath = s"../apps/$appsTag/$classification/$apkName"
    sdk.install_package(emu.serialID, apkPath, true)

    println("Starting MalwareActivity.")
    val mainActivity = "io.magnum.antimalware/.MalwareActivity"
    val amStart = s"am start -a android.intent.action.MAIN -n $mainActivity"
    sdk.remote_shell(emu.serialID, amStart)

    // Get the package name.
    val apkInfo = sdk.aapt_dump("badging", apkPath)
    val infoRegex(packageName) = apkInfo.split("\n")(0)

    //Thread.sleep(2147483647)    
    println("Monkey testing application '" + packageName + "'.")
    sdk.remote_shell(emu.serialID, s"monkey -p $packageName " + monkeyOpts)

    println(s"Pulling the arff for '$packageName'")
    sdk.remote_shell(emu.serialID, "touch /sdcard/magnum/dump")
    
    val deviceArff = "/sdcard/magnum/profile.arff"
    val hostArff = s"../arff/$arffTag/$classification/$packageName.arff"

    var i = 0;
    while (sdk.remote_shell(emu.serialID,
           s"[[ -f $deviceArff ]] && echo 'obtained'").get != "obtained" &&
           i < 10) {
      Thread.sleep(1000);
      i += 1
    }

    sdk.pull_from_device(emu.serialID, deviceArff, hostArff)      
    sdk.remote_shell(emu.serialID, "sync")

    var lastLine: String = "@data"
    for (line <- Source.fromFile(hostArff).getLines) {
      lastLine = line
    }
    if (lastLine == "@data") {
      println("Warning: Obtained empty ARFF.")
      s"rm -f $hostArff" !!;
    }

    sdk.remote_shell(emu.serialID, "rm /sdcard/magnum/dump")
    sdk.remote_shell(emu.serialID, "rm /sdcard/magnum/profile.arff")
    println("\n")
    val endTime = System.currentTimeMillis();
    println(s"Time to profile '$apkName': ${endTime-startTime}")
    result.toMap
  }
}
