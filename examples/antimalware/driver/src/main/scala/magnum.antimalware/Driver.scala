package magnum.antimalware

import java.io.{File,FileWriter}
import java.util.concurrent.atomic.AtomicInteger

import scala.actors._ // For Thread.sleep. TODO remove!
import scala.language.postfixOps
import scala.io.Source

import clasp._
import clasp.core._
import clasp.core.sdktools._

import scala.sys.process._
import scala.concurrent._
import ExecutionContext.Implicits.global

import scala.util.control.Breaks._

object Driver {
  lazy val infoRegex = """.*name='([^']*)'.*""".r
  var clasp: ClaspMaster = null

  var totalToProfile = 0
  var numProfiled: AtomicInteger = new AtomicInteger(0)

  def run(clasp: ClaspMaster, profilerApk: String, profilerMainActivity: String,
      appsTag: String, fvTag: String,
      maxBenignApps: Option[Int], maxMaliciousApps: Option[Int],
      throttle: Int, numberOfEvents: Int,
      emuOpts: EmulatorOptions) {
    this.clasp = clasp

    val monkeyOpts = "--pct-syskeys 0 " +
      "--pct-appswitch 0 " +
      "--pct-anyevent 0 " +
      "-s 0 " +
      s"--throttle $throttle " +
      s"$numberOfEvents"

    // Clean and make the `fvTag` directories.
    s"rm -rf ../fv/$fvTag" !!;
    s"mkdir -p ../fv/$fvTag/benign ../fv/$fvTag/malicious" !!
    val infoFile = new FileWriter(s"../fv/$fvTag/info.txt", false)
    infoFile.write(s"""
    |Information for these feature vectors.
    |avdTarget = '${emuOpts.avdTarget}'
    |abiName = '${emuOpts.abiName}'
    |adb monkey options: '$monkeyOpts'
    |profilerApk = $profilerApk
    |profilerMainActivity = $profilerMainActivity
    |appsTag = $appsTag
    |maxBenignApps = $maxBenignApps
    |maxMaliciousApps = $maxMaliciousApps
    |throttle = $throttle
    |numberOfEvents = $numberOfEvents
    """.stripMargin.trim)
    infoFile.close()

    // Queue all of the applications asynchronously.
    collectEmu("benign", profilerApk, profilerMainActivity, appsTag, fvTag,
      monkeyOpts, maxBenignApps)
    collectEmu("malicious", profilerApk, profilerMainActivity, appsTag, fvTag,
      monkeyOpts, maxMaliciousApps)

    // Wait for the applications to finish profiling and timeout
    // after N minutes if there is no activity.
    // TODO: This might not be working because a session hung.
    //       Even ctrl+C was blocked. I'm not sure what happened.
    var previousNumProfiled = 0; var count = 0;
    var minutesToTimeout = 10;
    println("Waiting for applications to finish profiling.")
    println("If nothing changes in " + minutesToTimeout + " minute(s), " +
      "assume we timed out and exit.")
    while (numProfiled.get < totalToProfile) {
      Thread.sleep(1000);
      count = (count + 1) % (60*minutesToTimeout)
      if (count == 0) {
        if (previousNumProfiled == numProfiled.get) {
          println("No applications profiled in " + minutesToTimeout
            + " minute(s). Exiting.")
          clasp.kill
          return
        }
      }
    }
    println("Profiled " + totalToProfile + " applications.")
    clasp.kill
  }

  def collectEmu(classification: String, profilerApk: String,
      profilerMainActivity: String, appsTag: String, fvTag: String,
      monkeyOpts: String, maxApps: Option[Int]) {
    var appsPath = s"../apps/$appsTag/$classification"
    var file: File = new File(appsPath)
    if (file.listFiles == null) {
      println(s"Warning: $appsPath contains no files.")
      return;
    }

    println(s"Adding $classification applications.")
    val startTime = System.currentTimeMillis()
    var i = 1
    breakable {
      for (apkFile <- file.listFiles) {
        if (maxApps.isDefined && i > maxApps.get) {
          break;
        }
        val apkName = apkFile.getName()
        totalToProfile += 1
        val f = clasp.register_on_new_emulator(
            (emu: Emulator) =>
              profileApkCallback(emu, classification, apkName,
                profilerApk, profilerMainActivity, appsTag, fvTag, monkeyOpts))
        f onSuccess {
          case data => println(
              s"""Emulator Task completed successfully on Node""" +
              s"""${data("node")},emulator ${data("serialID")}""")
          val total = numProfiled.incrementAndGet
          val time = System.currentTimeMillis() - startTime;
          println(s"Profiled $total in $time ms.")
        }
        f onFailure {
          case t => println(s"Future failed due to '${t.getMessage}'")
          numProfiled.incrementAndGet
        }
        i += 1
      }
    }
  }

  // Don't use global variables in a callback!
  // This is why we pass `profilerApk` and `fvTag`.
  def profileApkCallback(emu: Emulator, classification: String,
      apkName: String, profilerApk: String, profilerMainActivity:String,
      appsTag:String, fvTag: String, monkeyOpts: String): Map[String, Any] = {
    val startTime = System.currentTimeMillis();
    var result = scala.collection.mutable.Map[String, Any]()
    println(s"\n===========Profiling application: $apkName===========")
    result("serialID") = emu.serialID
    result("node") = "hostname".!!.stripLineEnd

    println("Installing the profiling application.")
    sdk.install_package(emu.serialID, profilerApk, true)

    var command = s"[[ -d /sdcard/magnum ]] || mkdir /sdcard/magnum"
    sdk.remote_shell(emu.serialID, command)

    val apkPath = s"../apps/$appsTag/$classification/$apkName"
    sdk.install_package(emu.serialID, apkPath, true)

    // TODO: Make the activity a param.
    println(s"Starting profiler's main class: $profilerMainActivity.")
    val amStart =
      s"am start -a android.intent.action.MAIN -n $profilerMainActivity"
    sdk.remote_shell(emu.serialID, amStart)

    // Get the package name.
    val apkInfo = sdk.aapt_dump("badging", apkPath)
    val infoRegex(packageName) = apkInfo.split("\n")(0)

    println("Monkey testing application '" + packageName + "'.")
    sdk.remote_shell(emu.serialID, s"monkey -p $packageName " + monkeyOpts)

    println(s"Pulling the fv for '$packageName'")
    val deviceArff = "/sdcard/magnum/vectors"
    val hostArff = s"../fv/$fvTag/$classification/$packageName.csv"
    sdk.pull_from_device(emu.serialID, deviceArff, hostArff)      
    sdk.remote_shell(emu.serialID, "sync")

    if (Source.fromFile(hostArff).getLines.length == 1) {
      println("Warning: Obtained no feature vectors.")
      s"rm -f $hostArff" !!;
    }

    sdk.remote_shell(emu.serialID, "rm /sdcard/magnum/vectors")
    println("\n")

    if (classification == "malicious") emu.rebootWhenFinished = true

    val endTime = System.currentTimeMillis();
    println(s"Time to profile '$apkName': ${endTime-startTime}")
    result.toMap
  }
}
