package magnum.antimalware

import java.io.File
import java.util.concurrent.atomic.AtomicInteger

import scala.actors._ // For Thread.sleep. TODO remove!
import scala.language.postfixOps

import clasp._
import clasp.core._
import clasp.core.sdktools._

import scala.sys.process._
import scala.concurrent._
import ExecutionContext.Implicits.global

object Driver {
  lazy val infoRegex = """.*name='([^']*)'.*""".r
  var clasp: ClaspMaster = null
  var apkList: Array[File] = null
  var profilerApk: String = null

  def run(clasp: ClaspMaster, profilerApk: String) {
    // TODO: Output count of ARFF files we already have.

    this.clasp = clasp
    this.profilerApk = profilerApk

    collectEmu("benign")
    //TODO
    //collectEmu("malicious")

    // TODO: Output final count of ARFF files.
  }

  def collectEmu(classification: String) {
    println(s"Profiling $classification applications.")
    var file: File = new File(s"../apps/$classification")
    apkList = file.listFiles

    var apkIndex: AtomicInteger = new AtomicInteger(0)
    val startTime = System.currentTimeMillis();
    for (apkFile <- apkList) {
      val apkName = apkFile.getName()
      // TODO: Don't add if we already have an arff.
      val f = clasp.register_on_new_emulator(
          (emu: Emulator) =>
            profileApkCallback(emu, classification, apkName))
        f onSuccess {
          case data => println(
              s"""Emulator Task completed successfully on Node""" +
              s"""${data("node")},emulator ${data("serialID")}""")
          val total = apkIndex.incrementAndGet
          val time = System.currentTimeMillis() - startTime;
          println(s"Profiled $total in $time ms.")
        }
        f onFailure {
          case t => println(s"Future failed due to ${t.getMessage}")
          apkIndex.incrementAndGet
        }
    }

    println(s"Waiting to finish $classification applications.")
    while (apkIndex.get < apkList.size) {
      Thread.sleep(1000);
    }
  }

  def profileApkCallback(emu: Emulator, classification: String,
      apkName: String): Map[String, Any] = {
    val startTime = System.currentTimeMillis();
    var result = scala.collection.mutable.Map[String, Any]()
    // TODO: Use the same logging mechanism as clasp.
    println(s"\n===========Profiling application: $apkName===========")
    result("serialID") = emu.serialID
    result("node") = "hostname".!!.stripLineEnd

    println("Installing the profiling application.")
    sdk.install_package(emu.serialID, profilerApk, true)

    var command = s"mkdir /sdcard/magnum"
    sdk.remote_shell(emu.serialID, command)

    var posNeg = "positive"
    if (classification == "Benign") posNeg = "negative"
    println(s"Setting the classification to '$posNeg'.")
    command = s"echo $posNeg > /sdcard/magnum/classification"
    sdk.remote_shell(emu.serialID, command)

    val apkPath = s"../apps/$classification/$apkName"
    sdk.install_package(emu.serialID, apkPath, true)

    println("Starting MalwareActivity.")
    val mainActivity = "org.vt.magnum.antimalware.main/.MalwareActivity"
    val amStart = s"am start -a android.intent.action.MAIN -n $mainActivity"
    sdk.remote_shell(emu.serialID, amStart)

    // Get the package name.
    val apkInfo = sdk.aapt_dump("badging", apkPath)
    val infoRegex(packageName) = apkInfo.split("\n")(0)

    //Thread.sleep(2147483647)    
    println("Monkey testing application '" + packageName + "'.")
    sdk.remote_shell(emu.serialID,
      s"monkey -p $packageName " +
      "--pct-syskeys 0 " +
      "--pct-appswitch 0 " +
      "--pct-anyevent 0 " +
      "-s 0 10000") //TODO seed // Before 10,000

    println(s"Pulling the arff for '$packageName'")
    // TODO: Change this location.
    sdk.pull_from_device(emu.serialID, "/sdcard/magnum/malware.arff",
        s"../arff/$classification/$packageName.arff")
    sdk.remote_shell(emu.serialID, "sync")
    println("\n")
    val endTime = System.currentTimeMillis();
    println(s"Time to profile '$apkName': ${endTime-startTime}")
    result.toMap
  }
}
